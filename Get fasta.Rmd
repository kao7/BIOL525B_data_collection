---
title: "TRAF_for_class"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r}
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
BiocManager::install("biomaRt")
install.packages("tidyverse")
install.packages(c("httr","jsonlite"))
install.packages("seqinr")

library(tidyverse)
library(biomaRt)
library(httr)
library(jsonlite)
library(seqinr)

#Get genes
IDs <- scan("diverse_proteomes.txt", character())
url_list <- tibble(ID = IDs,
                   URL = rep("https://www.ebi.ac.uk/interpro/api/protein/UniProt/entry/InterPro/IPR008974/proteome/uniprot/REPLACE/?page_size=300",length(IDs)),
                   URL2 = rep("https://www.ebi.ac.uk/interpro/api/protein/UniProt/entry/InterPro/IPR002083/proteome/uniprot/REPLACE/?page_size=300",length(IDs))
                   ) %>%
  mutate(URL = str_replace(URL, "REPLACE", ID)) %>%
  mutate(URL2 = str_replace(URL2, "REPLACE", ID))


res_ <- map(c(url_list$URL,url_list$URL2), GET)

saveRDS(res_, "res_.RDS")
res_<- readRDS("res_.RDS")

table(unlist(map(res_, c(status_code))))
# res_ <- discard(res_, ~.x$status_code == 204) #remove lists that don't have any data if any
data <- map(res_, "content") %>%
  map(~fromJSON(rawToChar(.))) %>%
  map(c("results","metadata","accession")) %>%
  unlist() %>%
  unique() # generates list of uniprot accessions containing interpro accessions - NOTE THAT SOME ISOFORMS MAY NOT BE INCLUDED

# IDs2 <- tibble(read_delim("tax_IDs_remainder.txt", col_names = FALSE, delim= "\n",col_types = "c"))
# url_list_ <- tibble(ID = unlist(IDs2),
#                    URL = rep("https://www.ebi.ac.uk/interpro/api/protein/UniProt/entry/InterPro/IPR008974/taxonomy/uniprot/REPLACE/?page_size=300",length(IDs2))) %>% 
#     mutate(URL = str_replace(URL, "REPLACE", ID))
# 
# res__ <- map(url_list_$URL, GET)
# res__ <- discard(res__, ~.x$status_code == 204)
# data2 <- map(res__, "content") %>%
#   map(~fromJSON(rawToChar(.))) %>%
#   map(c("results","metadata","accession")) %>%
#   purrr::flatten() %>%
#   as.character()%>%
#   as_tibble() %>%
#   distinct()
# 
# data_all <- rbind(data,data2)


url_list3 <- tibble(Accession = data, URL = rep("https://www.ebi.ac.uk/interpro/api/entry/InterPro/protein/UniProt/REPLACE?page_size=350",length(data))) %>%
  mutate(URL = str_replace(URL, "REPLACE", Accession)) 

res_3 <- map(url_list3$URL, GET) #get interpro data for each accession
table(unlist(map(res_3, c(status_code))))
# res_3 <- discard(res_3, ~.x$status_code == 204)

saveRDS(res_3, "res_3.RDS")
res_3<- readRDS("res_3.RDS")


meta <- map(res_3, "content") %>%
  map(~fromJSON(rawToChar(.))) %>%
  map("results")
  

itp_meta <- meta %>%
  map(c("metadata")) %>%
  map(~dplyr::select(.x, "accession","name","source_database","type")) %>%
  map(transpose)

itp_prot <- meta %>%
  map(c("proteins")) %>%
  map(~map(.x, ~dplyr::rename(.x, "uniprot_accession" = "accession"))) %>%
  map(~map(.x, ~dplyr::rename(.x, "uniprot_source_database" = "source_database"))) %>%
  map(~map(.x, purrr::flatten)) %>%
  map(~map(.x, purrr::flatten))

itp_ <-map2(itp_meta, itp_prot, ~map2(.x,.y, c))

itp_names <- itp_ %>%
  map(~map(., names)) %>%
  map(unlist) %>%
  purrr::reduce(union)

itp_ <- itp_ %>%
  map(transpose, .names = itp_names) %>%
  # map(~map_if(.x, is.data.frame, list)) %>%
  map(~as_tibble(.x, .name_repair = "unique")) %>%
  map(~unnest(.x, c("fragments", "model", "score"))) %>%
  map(~unnest(.x, fragments)) %>%
  map(transpose)

itp_names2 <- itp_ %>%
  map(~map(., names)) %>%
  map(unlist) %>%
  purrr::reduce(union) # to make sure all columns are kept

itp__ <- itp_ %>%
  map(transpose, .names = itp_names2) %>%
  map(~as_tibble(.x, .name_repair = "unique"))

pdl <- bind_rows(itp__, .id="Order") %>%
  unnest(cols = colnames(.)) %>%
  mutate(uniprot_accession = toupper(uniprot_accession))

# pdl_map <- pdl %>%
#   group_by(Order, uniprot_accession) %>%
#   summarise() %>%
#   drop_na(uniprot_accession)

pdl_type <- pdl %>%
  filter(type == "homologous_superfamily") %>%
  mutate(domain_code = recode(accession, "IPR008974" = "T", "IPR011333" = "B", "IPR013083" = "Z", "IPR038765" = "P", .default = "")) %>%
  mutate(mid = (end+start)/2) %>%
  group_by(uniprot_accession) %>%
  arrange(mid, .by_group = TRUE) %>%
  mutate(protein_type = paste0(domain_code, collapse = "")) %>%
  ungroup() %>%
  dplyr::select(uniprot_accession, protein_type) %>%
  distinct(uniprot_accession, .keep_all = TRUE)

pdl_type2 <- pdl %>%
  filter(type == "domain") %>% 
  mutate(domain_code = recode(name, 
                              "B-box-type zinc finger" = "Z",
                              "Zinc finger, RanBP2-type" = "Z",
                              "Zinc finger, ZZ-type" = "Z",
                              "Zinc finger, TAZ-type" = "Z",
                              "Zinc finger, TRAF-type" ="Z",
                              "Zinc finger, RING-type" = "Z",
                              "Zinc finger, SIAH-type" = "Z",
                              "U box domain" = "Z",
                              "BTB/POZ domain" = "B", 
                              "MATH/TRAF domain" = "T",
                              "Seven-in-absentia protein, TRAF-like domain" = "T",
                              "Peptidase C19, ubiquitin carboxyl-terminal hydrolase" = "P", 
                              "Ubiquitin carboxyl-terminal hydrolase 7, ICP0-binding domain" = "P",
                              "Ubiquitin carboxyl-terminal hydrolase, C-terminal" = "P",
                              "Ubiquitin specific protease domain" = "P",
                              .default = "")) %>%
  mutate(mid = (end+start)/2) %>%
  group_by(uniprot_accession) %>%
  arrange(mid, .by_group = TRUE) %>%
  mutate(protein_type2 = paste0(domain_code, collapse = "")) %>%
  mutate(protein_type2 = str_replace_all(protein_type2, "(P)\\1+", "\\1")) %>%
  ungroup() %>%
  dplyr::select(uniprot_accession, protein_type2) %>%
  distinct(uniprot_accession, .keep_all = TRUE)

# as.data.frame(table(as.factor(pdl_type2$name)))
pdl_withtype <- pdl %>%
  left_join(pdl_type) %>%
  left_join(pdl_type2)  %>%
  mutate(TEST = ifelse(protein_type == protein_type2,"","FIX ME")) %>%
  rowwise() %>% 
  mutate(protein_type_ = c_across(starts_with("protein_type"))[which.max(nchar(c_across(starts_with("protein_type"))))]) %>%
  mutate(ALL_have_T = str_match(protein_type_, "T")) %>% #check if all have T
  mutate(domain_have_T = str_match(protein_type2, "T")) %>%
  mutate(HSF_have_T = str_match(protein_type, "T"))


url_list_fasta<- tibble(ID= data,
                   URL = rep("https://www.uniprot.org/uniprot/REPLACE&format=fasta", length(data))) %>%
  mutate(URL = str_replace(URL, "REPLACE", ID))

res_f <- map(url_list_fasta$URL, GET)
table(unlist(map(res_f, c(status_code))))
# res_f <- discard(res_f, ~.x$status_code == 204)
saveRDS(res_f, "res_f.RDS")
res_f<- readRDS("res_f.RDS")


fasta <- map(res_f, "content") %>%
  map(~rawToChar(.)) %>%
  purrr::flatten() %>%
  as.character()

# fileconn <- file("May28.fasta")
# writeLines(fasta, fileconn)
# close(fileconn)


fasta2 <- map(res_f, "content") %>%
  map(~rawToChar(.)) %>%
  transpose() %>%
  as_tibble(.name_repair = "unique") %>%
  separate(`...1`, into = c("one", "two", "three"), sep="\\|") %>%
  separate(three, into = c("four","seq"), sep= "\n", extra = "merge") %>%
  separate(four, into = c("four", "species"), sep = "=", extra = "merge") %>%
  separate(species, into = c("species", "leftover"), sep = "OX=", extra = "merge") %>%
  mutate(seq = str_replace_all(seq, "\n", "")) %>%
  rename(uniprot_accession = two)

# pdl_TRAF <- pdl_withtype %>%
#   group_by(uniprot_accession) %>% 
#   # dplyr::filter(accession == "IPR018121") %>%
#   # nrow() #count number of SINA = 82
#   dplyr::filter(any(accession == "IPR018121")) %>%
#   dplyr::filter(accession == "IPR008974") %>%
#   nrow() # count number of HSF TRAF = 82 --> each SINA should be covered by HSF --> can exclude the domain


pdl_TRAF <- pdl_withtype %>%
  group_by(uniprot_accession) %>% 
  dplyr::filter(
    (accession == "IPR002083" & uniprot_accession != "A0A7I4D1F8" & uniprot_accession !="A0A2K1L2Z6") |  #TRAF domain for all but misannotated ones
      ((uniprot_accession == "A0A7I4D1F8"| uniprot_accession == "A0A2K1L2Z6") & accession == "IPR008974") | #add HSF for misannotated ones
      (any(accession == "IPR018121") & accession == "IPR008974") | #add HSF for SINA ones
      (is.na(domain_have_T) & accession == "IPR008974")) %>% #add HSF for ones missing TRAF domain annotation
  group_by(uniprot_accession) %>%
  mutate(id = 1:n()) %>%
  mutate(n = n())%>%
  ungroup() %>%
  mutate(domain_length = end-start) %>%
  mutate(T_n = str_count(protein_type_, "T")) #%>%
  # filter(n != T_n) #966

##This code is for using mostly HSF instead
# pdl_TRAF <- pdl_withtype %>%
#   dplyr::filter(accession == "IPR008974" | (is.na(HSF_have_T) & accession == "IPR002083")) %>%
#   group_by(uniprot_accession) %>% 
#   mutate(id = 1:n()) %>%
#   mutate(n = n())%>%
#   ungroup() %>%
#   mutate(domain_length = end-start) %>%
#   mutate(T_n = str_count(protein_type_, "T")) %>%
#   filter(n != T_n)


pdl_fasta <- left_join(pdl_TRAF, fasta2, by = "uniprot_accession") %>%
  mutate(subseq_4_compare = str_sub(seq, start = start, end = end)) %>%
  mutate(start = start-10)%>%
  mutate(end= end+10) %>%
  mutate(start = if_else(start <0, 0, start)) %>%
  mutate(end = if_else(end > as.numeric(protein_length), as.numeric(protein_length), end)) %>%
  # mutate(test = protein_length - end)
  mutate(subseq = str_sub(seq, start = start, end = end)) %>%
  mutate(species_short = word(species, 1, 2)) %>%
  unite(trace, id, n, sep= "/", remove = FALSE) %>%
  unite(trace_ua, uniprot_accession, trace, sep= "_", remove = FALSE) %>%
  unite(fasta_name, trace_ua, protein_type_, species_short, sep= " ", remove = FALSE) %>%
  mutate(simp_type = if_else(str_detect(protein_type_, "B"),"Z",
                             if_else(str_detect(protein_type_, "Z"),"Z",
                                     if_else(str_detect(protein_type_, "P"), "P",
                                             if_else(str_detect(protein_type_, "TTTT"), "4T", "T"))))) %>%
  mutate(tip = row_number()) %>%
  mutate(t = "t")%>%
  unite("tip", "t","tip", sep = "") %>%
  relocate(tip)
  # mutate(fasta_name = str_replace(fasta_name, "_", "of")) %>%
  # separate(species, into =c("genus", "species", "subspeciesname"), sep = " ", remove = FALSE, extra = "merge")

# write_csv(pdl_fasta, "pdl_fasta.csv")

# write_csv(pdl_fasta, "pdl_fasta.csv")
# write.fasta(as.list(pdl_fasta$subseq), names= pdl_fasta$fasta_name, file.out = "June5subseq.fasta", as.string = TRUE)


#STILL HAVE TO GET RID OF DUPLICATES & SHORT SEQUENCES


#str(unique(pdl_TRAF$uniprot_accession)) #729

res_genes <- map(c('MGI_ID','SGD_ID','WORMBASE_ID','ENSEMBLGENOME_ID'),
                 ~POST(url = "https://www.uniprot.org/uploadlists/",
                      body = list(from = 'ACC+ID',
                        to = .x,
                        format = 'tab',
                        query = paste0(unique(pdl_TRAF$uniprot_accession),collapse = " ")
                        )
                      )
)

up_2_genes <- map_dfr(res_genes, ~content(.x, type = 'text/tab-separated-values')) %>% 
# up_2_genes[[3]]$To <- up_2_genes[[3]]$To %>% as.character()
# up_2_genes <- up_2_genes %>%
  # reduce(rbind) %>%
  rename(uniprot_accession = From, Gene_ID = To) %>%
  distinct(uniprot_accession, Gene_ID, .keep_all = TRUE)


up_2_genes2 <- content(
  POST(url = "https://www.uniprot.org/uploadlists/",
                      body = list(from = 'ACC+ID',
                        to = 'GENENAME',
                        format = 'tab',
                        query = (pdl_fasta %>% 
                                   dplyr::filter(species == "Marchantia polymorpha subsp. ruderalis " | species == "Papaver somniferum " | species == "Asparagus officinalis ") %>% 
                                   distinct(uniprot_accession) %>% 
                                   pull() %>% 
                                   paste0(collapse = " "))
                    ))
  , type = 'text/tab-separated-values') %>% 
  rename(uniprot_accession = From, Gene_ID = To) %>%
  distinct(uniprot_accession, Gene_ID, .keep_all = TRUE)

up_2_genes3 <- content(
  POST(url = "https://www.uniprot.org/uploadlists/",
                      body = list(from = 'ACC+ID',
                        to = 'GENENAME',
                        format = 'tab',
                        query = (left_join(pdl_fasta, rbind(up_2_genes, up_2_genes2), by = "uniprot_accession") %>% 
                                   filter(is.na(Gene_ID)) %>% 
                                   distinct(uniprot_accession) %>% 
                                   pull() %>% 
                                   paste0(collapse = " "))
                    ))
  , type = 'text/tab-separated-values') %>% 
  rename(uniprot_accession = From, Gene_ID = To) %>%
  distinct(uniprot_accession, Gene_ID, .keep_all = TRUE)


gID_mappings <- rbind(up_2_genes, up_2_genes2, up_2_genes3)
saveRDS(gID_mappings, "gID_mappings.RDS")
gID_mappings <- readRDS("gID_mappings.RDS")


#get gene IDS for all sequences
pdl_fasta_gID <- gID_mappings  %>%
  mutate(Gene_ID = str_replace(Gene_ID, "LOC_", "")) %>%
  mutate(Gene_ID = str_replace(Gene_ID, "v3$", "")) %>%
  # group_by(uniprot_accession) %>%
  # filter(n()>1) # some uniprot accession map to multiple gene IDs, but doesn't matter so much, since we care more about the other way around.
  group_by(Gene_ID) %>%
  mutate(isoform_problem = if_else(n()>1,"Yes", "No")) %>%
  group_by(uniprot_accession) %>%
  mutate(duplicated_UA = if_else(n()>1,"Yes", "No"))%>%
  right_join(pdl_fasta) %>%
  relocate(tip) %>%
  mutate(uniprot_accession_l = nchar(uniprot_accession)) # note this includes 8 situations where one uniprot matches to multiple gene IDs

# saveRDS(pdl_fasta_gID, "pdl_fasta_gID.RDS")
# pdl_fasta_gID<- readRDS("pdl_fasta_gID.RDS")


pdl_fasta_gID <- pdl_fasta_gID %>%
  group_by(Gene_ID) %>%
  arrange(nchar(uniprot_accession), .by_group = TRUE) %>% # to keep shorter accession
  ungroup() %>%
  group_by(Gene_ID, uniprot_accession) %>%
  # arrange(trace_ua, .by_group = TRUE) %>%
  mutate(subseq_c = paste0(subseq_4_compare, collapse = "_")) %>% # collapse TRAF domains from each uniprot_accession into one
  ungroup() %>%
  group_by(Gene_ID) %>%
  arrange(nchar(uniprot_accession), .by_group = TRUE) %>% #to keep the identical sequence  with the shorter accession name
  # group_by(Gene_ID) %>%
  distinct(trace, subseq_c, .keep_all = TRUE)%>%
  ungroup() 
  

#delete isoforms that have less than all domains  
UA_2_del <- pdl_fasta_gID %>%  
  group_by(Gene_ID) %>%
  filter(n()>1) %>%
  distinct(n, .keep_all = TRUE) %>%
  group_by(Gene_ID) %>%
  filter(n()>1) %>%
  group_by(Gene_ID) %>%
  arrange(desc(n), .by_group = TRUE) %>%
  ungroup() %>%
  distinct(Gene_ID, .keep_all = TRUE) %>%
  dplyr::select(uniprot_accession, Gene_ID, n)


pdl_fasta_gID_ <- anti_join(pdl_fasta_gID, UA_2_del, by = "uniprot_accession") %>%
  # distinct(uniprot_accession, .keep_all = TRUE) %>%
  # group_by(seq,subseq_c) %>%
  group_by(Gene_ID, trace) %>%
  # filter(n()>1) %>%
  # distinct(Gene_ID)
  mutate(isoform_to_man_remove = if_else(n()>1,"Yes", "No")) %>%
  ungroup() %>%
  mutate(domain_size = if_else(domain_length <90, "SHORT", "OK"))

    # group_by(uniprot_accession) %>%
  # filter(n()>1) # some uniprot accession map to multiple gene IDs, but doesn't matter so much, since we care more about the other way around.


#delete isoforms that have short domain
UA_2_del2 <- pdl_fasta_gID_%>%  
  group_by(Gene_ID, trace) %>%
  filter(n()>1) %>%
  ungroup() %>% group_by(uniprot_accession) %>%
  mutate(short = if_else(any(domain_size == "SHORT"), "SHORT", "NORMAL")) %>%
  ungroup() %>% group_by(Gene_ID) %>%
  # filter(!any(short == "NORMAL")) #check if any only have "short" sequences - only one - remove A0A2K1XQX7, keep A0A2K1XQY0
  filter(short == "SHORT") %>%
  filter(uniprot_accession != "A0A2K1XQY0") %>%
  distinct(uniprot_accession)

pdl_fasta_gID_ <- anti_join(pdl_fasta_gID_, UA_2_del2, by = "uniprot_accession") #%>%  
  # group_by(Gene_ID, trace) %>%
  # filter(n()>1) %>%
  # ungroup() %>% group_by(Gene_ID) %>%
  # relocate(domain_length, start, end, protein_length)

#delete isoforms - manual annotation
UA_2_del3 <- tibble(uniprot_accession = strsplit("A8MQL1 F4I476 A0A1P8ARC9 A0A1P8AX66 O48777 F4JDF6 Q4PSK6 A0A1P8B3G0 F4JKT0 A8MR02 F4KG56 A0A1P8BC00 A0A0A6YWE7 A0A0A6YXL9 A0A0A6YWE7 Q6A4J8 A0A0A6YVW8 E0CYU8 A0A0N7KEM0 A0A7I4BK46 A0A7I4F8L4 A0A2K1K5T7 G3MU79 Q17782 P34324 A0A3N7G5T9 U7DYS1 A0A2K1X3E1 A0A3N7G431 A0A3N7G464 A0A3N7G7H1 A0A3N7FWR0 A0A3N7FP35 A0A3N7FDW1 A0A2K1ZES4 A0A2K2A8B1", " ")[[1]], by = "uniprot_accession")


pdl_fasta_gID_ <- anti_join(pdl_fasta_gID_, UA_2_del3, by = "uniprot_accession")

#delete genes that have identical sequences (uniprot IDs mapping to multiple genes)
UA_2_del4 <- pdl_fasta_gID_ %>%  
  group_by(uniprot_accession, trace) %>%
  filter(n()>1) %>%
  arrange(nchar(Gene_ID)) %>%
  ungroup() %>% group_by(uniprot_accession) %>%
  slice(1)

pdl_fasta_gID_ <- anti_join(pdl_fasta_gID_, UA_2_del4, by = "uniprot_accession") %>%
  group_by(subseq) %>%
  filter(n()>1) #13 sequences still have 


#    mutate(inside = map(subseq_4_compare, ~str_detect(.x, subseq_4_compare)))
# adf<-  map(pdl_fasta_gID_$subseq_4_compare, ~str_detect(.x, pdl_fasta_gID_$subseq_4_compare))



tree_annot <- pdl_fasta_gID_ %>%
  ungroup() %>%
  arrange(nchar(Gene_ID))%>%
  distinct(tip, .keep_all = TRUE) %>%
  unite(UP_ID,  uniprot_accession, Gene_ID, trace, protein_type_, species_short)

write_csv(tree_annot, "pdl_fasta.csv")
write.fasta(as.list(tree_annot$subseq), names= tree_annot$UP_ID, file.out = "June7subseq_noiso.fasta", as.string = TRUE)












no_ID <- anti_join(pdl_TRAF, up_2_genes, by = "uniprot_accession") %>%
  distinct(uniprot_accession, .keep_all = TRUE)

# 
# 
# 
# url_list_gene<- tibble(ID= data,
#                    URL = rep("https://www.uniprot.org/uniprot/REPLACE&format=txt", length(data))) %>%
#   mutate(URL = str_replace(URL, "REPLACE", ID))
# 
# res_gene <- map(url_list_gene$URL, GET)
# table(unlist(map(res_gene, c(status_code))))
# 
# saveRDS(res_gene, "res_gene.RDS")
# res_gene<- readRDS("res_gene.RDS")
# 
# genes <- map(res_gene, "content") %>%
#   map(~rawToChar(.))
#   # purrr::flatten() %>%
#   # as.character()
# 
# 
# gene_annot <- map(genes, ~as_tibble(read_lines(.x))) %>%
#   map(~filter(.x, str_detect(.x$value, "DR   MGI|DR   EnsemblMetazoa|DR   WormBase|DR   EnsemblFungi|DR   EnsemblPlants")) %>% transpose())













BiocManager::install("ggtree")
BiocManager::install("treeio")
install.packages("svglite")
library(ggtree)
library(treeio)
library(ape)
library(svglite)

raxml_file <- system.file("C:/Users/User/Desktop/Phylogeny course/HWK/BIOL525B_data_collection/RAxML-2021.06.05-Run.1/", 
                          "RAxML_result.file.out.RUN.0",
                          package= "treeio")
raxml <- read.tree("RAxML-2021.06.05-Run.1/RAxML_mesquite_ML_Trees.file.out")
raxml <- raxml[[1]]


# 
# df <- data.frame(Species = tree_annot$species_short,
#                  Isoform_to_man_remove = tree_annot$isoform_to_man_remove)
# rownames(df) <- tree_annot$tip


raxml_annot <- ggtree(raxml, layout = "circular") %<+% tree_annot +
  geom_tiplab(aes(label= UP_ID, color = isoform_to_man_remove), size = 2) +
  geom_tippoint(aes(fill = domain_size), shape = 21, size = 2) 

raxml_annot_ <- gheatmap(raxml_annot, tree_annot %>% column_to_rownames(var = "tip") %>%dplyr::select(species), offset= 1, width = 0.03, colnames = FALSE)
# raxml_annot_2 <-gheatmap(raxml_annot_, df[, "Isoform_to_man_remove", drop = F], offset=1.3, width = 0.03, colnames = FALSE)



# +
#   geom_tiplab(aes(label = species_short, color = species_short)
#   # geom_tiplab(aes(label = species_short, color = species_short), align = T, size = 2, linetype = NA, offset = 1, hjust = 0.05) +
# 
# 
# 
#   
#   
# 
#   geom_fruit(data = tree_annot,
#              geom = geom_tile,
#              mappings = )






ggsave("raxml_annotated.pdf", plot = raxml_annot_,
       device = "pdf", 
       width = 1000, 
       height =1000, 
       units = "mm",
       dpi=300,
       limitsize = FALSE)


  
```

##look up duplicates
```{r}


ensemblp <- useEnsemblGenomes(biomart = "plants_mart")
ensemblp_datasets <- as_tibble(listDatasets(ensemblp)) %>%
  separate(description, into = c("genus", "species", "speciesdetails"), sep = " ", extra = "merge")

species_to_search <- distinct(pdl_fasta, genus, species, subspeciesname) %>% dplyr::select(genus,species,subspeciesname) %>%
  left_join(ensemblp_datasets) %>%
  drop_na(dataset) %>%
  filter(!str_detect(dataset, "oindica_eg_gene")) %>%
  pull(dataset)

pdl_fasta_ <- left_join(pdl_fasta, species_to_search) %>%
  drop_na(dataset) %>%
  group_by(dataset)

pdl_fasta_split <- pdl_fasta_ %>%
  group_split(.keep=TRUE)

search_biomart_filters <- function(dataset){
  as_tibble(
    rbind(
    searchAttributes(useEnsemblGenomes(biomart = "plants_mart", dataset = dataset), pattern ="uniprot"),
    searchAttributes(useEnsemblGenomes(biomart = "plants_mart", dataset = dataset), pattern ="swiss")
  ))
}

searchAttributes(useEnsemblGenomes(biomart = "plants_mart", dataset = "athaliana_eg_gene"), pattern ="uniprot")
biomart_filters <- map(species_to_search$dataset, search_biomart_filters)





Filters <- "uniprotsptrembl"
Attributes <- c("ensembl_gene_id","ensembl_transcript_id", "uniprotsptrembl")

Search_biomart <- function(search_terms, biomart = "plants_mart", attributes = Attributes, filters = Filters){
  mart_ID <- useEnsemblGenomes(biomart = biomart, dataset = search_terms$dataset[[1]])
  as_tibble(
    getBM(attributes = attributes,
      filters = filters,
      values = search_terms$uniprot_accession, 
      mart = mart_ID)
  )
}
Ensembl_annot <- map(pdl_fasta_split, Search_biomart)
pdl_fasta_split <- pdl_fasta_split[-4]
Ensembl_annot2 <- map(pdl_fasta_split, Search_biomart, filters = "uniprotswissprot", attributes = c("ensembl_gene_id","ensembl_transcript_id", "uniprotswissprot"))
Ensembl_annot_full <- c(Ensembl_annot, Ensembl_annot2) %>%
  discard(function(x) nrow(x) == 0) %>%
  reduce(full_join, by = "ensembl_gene_id")


#TIR_list <- map(dataset_id, Search_biomart) #if looking through multiple species
#str(TIR_list)
#TIR_list <- TIR_list$athaliana_eg_gene 

TIR_list <- Search_biomart(dataset_id)
```
